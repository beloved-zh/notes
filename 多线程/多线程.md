# 1、线程简介

## 1.1、多任务

多任务处理是指用户可以在同一时间内运行多个应用程序,每个应用程序被称作一个任务。Linux、windows就是支持多任务的操作系统。

当多任务操作系统使用某种**任务调度策略**允许两个或更多进程并发共享一个处理器时，**事实上处理器在某一时刻只会给一件任务提供服务。因为任务调度机制保证不同任务之间的切换速度十分迅速，因此给人多个任务同时运行的错觉。**

多任务系统中有3个功能单位：任务、进程和线程。

百度百科：https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1/1011764?fr=aladdin

## 1.2、进程

**进程（Process）**：是计算机中的程序关于某数据集合上的一次运行活动，是**系统进行资源分配和调度的基本单位，是操作系统结构的基础**。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，**进程是线程的容器**。程序是指令、数据及其组织形式的描述，进程是程序的实体。

百度百科：https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503?fr=aladdin

## 1.3、线程

**线程（thread）**：是**操作系统能够进行运算调度的最小单位**。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，**一个进程中可以并发多个线程，每条线程并行执行不同的任务**。

**线程是独立调度和分派的基本单位**。

百度百科：https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin

## 1.4、多线程

**多线程（multithreading）**：是指从软件或者硬件上实现**多个线程并发执行的技术**。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理” 

百度百科：https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin

**普通方法调用和多线程**

![image-20200922203037957](image-20200922203037957.png)

## 1.5、Process与Thread

- 程序是指令和数据的有序集合，其本身没有任何运行的焊锡，是一个静态的概念
- **进程**是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位
- 通常一个进程中可以包含若干个**线程**，一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位

> 注意：很多多线程是模拟出来的，真正的多线程是指有很多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一时间点，CPU只能执行一个代码，因为切换很快，所以就有同时执行的错觉

**总结：**

- 线程就是独立的执行路径
- 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主程序，GC线程
- main()称之为主线程，为系统入口，用于执行整个程序
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预
- 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
- 线程会带来额外的开销，如CPU调度时间，并发控制开销
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致

# 2、线程创建

## 2.1、Thread

- 自定义线程类继承**Thread**类
- 重写**run()**方法，编写线程执行体
- 创建线程对象，调用**start()**方法启动线程

**线程不一定立即执行，CPU安排调度**

### 2.1.1、测试

```java
package com.zh.thread;

/**
 * @author Beloved
 * @date 2020/9/22 20:49
 * 1、继承Thread类
 * 2、重写run()方法
 * 3、调用start开启线程
 */
public class Test1 extends Thread {

    @Override
    public void run() {
        // run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("run--->"+i);
        }

    }

    public static void main(String[] args) {
        // main线程，主线程

        // 创建线程对象
        Test1 thread1 = new Test1();

        // 开启线程
        thread1.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("main--->"+i);
        }
    }
}
```

运行结果

![image-20200922210015938](image-20200922210015938.png)

### 2.1.2、多线程下载图片

**commons-io工具类下载图片**

```xml
<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.8.0</version>
</dependency>
```

```java
package com.zh.thread;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

/**
 * @author Beloved
 * @date 2020/9/22 21:02
 * 多线程同步下载图片
 */
public class Test02 extends Thread{

    private String url;
    private String name;

    public Test02(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public void run() {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载文件名为："+name);
    }

    public static void main(String[] args) {
        Test02 t1 = new Test02("https://api.btstu.cn/sjbz/api.php", "1.jpg");
        Test02 t2 = new Test02("https://api.btstu.cn/sjbz/api.php", "2.jpg");
        Test02 t3 = new Test02("https://api.btstu.cn/sjbz/api.php", "3.jpg");

        t1.start();
        t2.start();
        t3.start();
    }
}

/**
 * 下载器
 */
class WebDownloader{
    // 下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常");
        }
    }
}
```

![image-20200922212218710](image-20200922212218710.png)

### 2.1.3、总结

**多线程并不是按顺序执行，而是由CPU调度**

## 2.2、Runnable

**推荐使用Runnable对象，因为Java单继承有局限性**

- 实现**Runnable接口**
- 实现**run()**方法，编写线程执行体
- 创建线程对象，调用**start()**方法启动线程

### 2.2.1、测试

```java
package com.zh.runnable;

/**
 * @author Beloved
 * @date 2020/9/22 21:27
 * 1、实现Runnable接口
 * 2、重写run方法
 * 3、执行线程需要丢入Runnable接口实现类，调用start方法
 */
public class Test01 implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("run--->"+i);
        }
    }

    public static void main(String[] args) {
        Test01 t1 = new Test01();

        new Thread(t1).start();

        for (int i = 0; i < 20; i++) {
            System.out.println("main--->"+i);
        }
    }
}
```

![image-20200922213237884](image-20200922213237884.png)

### 2.2.2、多线程下载图片

```java
package com.zh.runnable;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

/**
 * @author Beloved
 * @date 2020/9/22 21:33
 */
public class Test02 implements Runnable{

    private String url;
    private String name;

    public Test02(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public void run() {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载文件名为："+name);
    }

    public static void main(String[] args) {
        Test02 t1 = new Test02("https://api.btstu.cn/sjbz/api.php", "1.jpg");
        Test02 t2 = new Test02("https://api.btstu.cn/sjbz/api.php", "2.jpg");
        Test02 t3 = new Test02("https://api.btstu.cn/sjbz/api.php", "3.jpg");

        new Thread(t1).start();
        new Thread(t2).start();
        new Thread(t3).start();
    }
}

/**
 * 下载器
 */
class WebDownloader{
    // 下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常");
        }
    }
}
```

![image-20200922213629612](image-20200922213629612.png)

## 2.3、Callable

- 实现Callable接口，需要返回值类型
- 重写call方法，需要抛出异常
- 创建目标对象
- 创建执行服务：`ExecutorService ser = Executors.newFixedThreadPool(1);`
- 提交执行：`Future<Boolean> result = ser.submit(t1);`
- 获取结果：`boolean r = result.get();`
- 关闭服务：`ser.shutdownNow();`

### 2.3.1、多线程下载图片

```java
package com.zh.callable;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

/**
 * @author Beloved
 * @date 2020/9/22 21:48
 */
public class Test01 implements Callable<Boolean> {

    private String url;
    private String name;

    public Test01(String url, String name) {
        this.url = url;
        this.name = name;
    }

    // 自定义返回值
    @Override
    public Boolean call() throws Exception {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载文件名为："+name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Test01 t1 = new Test01("https://api.btstu.cn/sjbz/api.php", "1.jpg");
        Test01 t2 = new Test01("https://api.btstu.cn/sjbz/api.php", "2.jpg");
        Test01 t3 = new Test01("https://api.btstu.cn/sjbz/api.php", "3.jpg");

        // 创建执行服务     nThreads：多少个线程
        ExecutorService ser = Executors.newFixedThreadPool(3);

        // 提交执行
        Future<Boolean> rs1 = ser.submit(t1);
        Future<Boolean> rs2 = ser.submit(t2);
        Future<Boolean> rs3 = ser.submit(t3);

        // 获取结果
        Boolean r1 = rs1.get();
        Boolean r2 = rs2.get();
        Boolean r3 = rs3.get();

        System.out.println(r1);
        System.out.println(r2);
        System.out.println(r3);

        // 关闭服务
        ser.shutdownNow();
    }
}

/**
 * 下载器
 */
class WebDownloader{
    // 下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常");
        }
    }
}
```

![image-20200922220012406](image-20200922220012406.png)

## 2.4、总结

**继承Thread类：**

- 子类继承Thread类具备多线程能力
- 启动线程：子类对象`.start()`
- 不建议使用：避免OOP单继承局限性

**实现Runnable接口：**

- 实现接口Runnable具有多线程能力
- 启动线程：传入目标对象+Thread对象.start()
- 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

**实现Callable接口：**

- 实现接口Callable具有多线程能力
- 启动线程：见2.3
- 不推荐使用：掌握即可

# 3、并发问题

**当多个线程同时操作同一个对象时，有可能同一时间操作同一数据，导致线程不安全，数据紊乱**

## 3.1、买火车票

```java
package com.zh.concurrent;

/**
 * @author Beloved
 * @date 2020/9/22 22:12
 */
public class Test01 implements Runnable {

    // 票数
    private int ticketNums = 10;

    @Override
    public void run() {
        while (true) {
            if (ticketNums <= 0) {
                break;
            }
            // 模拟延迟
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Thread.currentThread().getName()：获取当前线程名
            System.out.println(Thread.currentThread().getName()+"--->拿到了第"+ticketNums--+"票");
        }
    }


    public static void main(String[] args) {
        Test01 t = new Test01();

        new Thread(t,"张三").start();
        new Thread(t,"李四").start();
        new Thread(t,"王五").start();
    }
}
```

![image-20200922221905763](image-20200922221905763.png)

# 4、Lamda

- 避免匿名内部类定义过多
- 可以让代码看起来简洁
- 去掉没有意义的代码，只留核心的逻辑

**其实质属于函数式编程的概念**

函数式接口的定义：

- 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口

  ```java
  public interface Runnable{
      public abstract void run();
  }
  ```

- 对于函数式接口，可以通过Lamda表达式创建该接口

  ```java
  new Thread( ()-> System.out.println("你好")).start();
  ```

## 4.1、推导Lamda

```java
package com.zh.lamda;

/**
 * @author Beloved
 * @date 2020/9/23 0:15
 */
public class TestLamda01 {

    // 3.静态内部类
    static class Like2 implements ILike{

        @Override
        public void lamda() {
            System.out.println("i like lamda--->2");
        }
    }

    public static void main(String[] args) {

        ILike like = new Like();
        like.lamda();

        like = new Like2();
        like.lamda();

        // 4.局部内部类
        class Like3 implements ILike{

            @Override
            public void lamda() {
                System.out.println("i like lamda--->3");
            }
        }
        like = new Like3();
        like.lamda();

        // 5.匿名内部类。 没有类名,必须借助接口或者父类
        like = new ILike() {
            @Override
            public void lamda() {
                System.out.println("i like lamda--->4");
            }
        };
        like.lamda();

        // 6.Lamda简化
        like = ()-> {
            System.out.println("i like lamda--->5");
        };
        like.lamda();
    }

}

// 1.定义一个函数式接口
interface ILike{
    void lamda();
}

// 2.实现类
class Like implements ILike{

    @Override
    public void lamda() {
        System.out.println("i like lamda--->1");
    }
}
```

## 4.2、Lamda简化

**去除花括号代码体前提只有一行**

```java
package com.zh.lamda;

/**
 * @author Beloved
 * @date 2020/9/23 0:27
 */
public class TestLamda02 {

    public static void main(String[] args) {

        // Lamda简化
        ILove love = (String name)->{
            System.out.println("I Love " + name);
        };

        // 简化：去除参数类型
        love = (name)->{
            System.out.println("I Love " + name);
        };

        // 简化：去除括号
        love = name->{
            System.out.println("I Love " + name);
        };

        // 简化：去除花括号
        love = name-> System.out.println("I Love " + name);

        love.love("Java");

    }
}

interface ILove{
    void love(String name);
}
```

# 5、线程状态

