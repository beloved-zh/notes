# 1、线程简介

## 1.1、多任务

多任务处理是指用户可以在同一时间内运行多个应用程序,每个应用程序被称作一个任务。Linux、windows就是支持多任务的操作系统。

当多任务操作系统使用某种**任务调度策略**允许两个或更多进程并发共享一个处理器时，**事实上处理器在某一时刻只会给一件任务提供服务。因为任务调度机制保证不同任务之间的切换速度十分迅速，因此给人多个任务同时运行的错觉。**

多任务系统中有3个功能单位：任务、进程和线程。

百度百科：https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1/1011764?fr=aladdin

## 1.2、进程

**进程（Process）**：是计算机中的程序关于某数据集合上的一次运行活动，是**系统进行资源分配和调度的基本单位，是操作系统结构的基础**。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，**进程是线程的容器**。程序是指令、数据及其组织形式的描述，进程是程序的实体。

百度百科：https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503?fr=aladdin

## 1.3、线程

**线程（thread）**：是**操作系统能够进行运算调度的最小单位**。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，**一个进程中可以并发多个线程，每条线程并行执行不同的任务**。

**线程是独立调度和分派的基本单位**。

百度百科：https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin

## 1.4、多线程

**多线程（multithreading）**：是指从软件或者硬件上实现**多个线程并发执行的技术**。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理” 

百度百科：https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin

**普通方法调用和多线程**

![image-20200922203037957](image-20200922203037957.png)

## 1.5、Process与Thread

- 程序是指令和数据的有序集合，其本身没有任何运行的焊锡，是一个静态的概念
- **进程**是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位
- 通常一个进程中可以包含若干个**线程**，一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位

> 注意：很多多线程是模拟出来的，真正的多线程是指有很多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一时间点，CPU只能执行一个代码，因为切换很快，所以就有同时执行的错觉

**总结：**

- 线程就是独立的执行路径
- 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主程序，GC线程
- main()称之为主线程，为系统入口，用于执行整个程序
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预
- 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
- 线程会带来额外的开销，如CPU调度时间，并发控制开销
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致

# 2、线程创建

## 2.1、Thread

- 自定义线程类继承**Thread**类
- 重写**run()**方法，编写线程执行体
- 创建线程对象，调用**start()**方法启动线程

**线程不一定立即执行，CPU安排调度**

### 2.1.1、测试

```java
package com.zh.thread;

/**
 * @author Beloved
 * @date 2020/9/22 20:49
 * 1、继承Thread类
 * 2、重写run()方法
 * 3、调用start开启线程
 */
public class Test1 extends Thread {

    @Override
    public void run() {
        // run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("run--->"+i);
        }

    }

    public static void main(String[] args) {
        // main线程，主线程

        // 创建线程对象
        Test1 thread1 = new Test1();

        // 开启线程
        thread1.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("main--->"+i);
        }
    }
}
```

运行结果

![image-20200922210015938](image-20200922210015938.png)

### 2.1.2、多线程下载图片

**commons-io工具类下载图片**

```xml
<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.8.0</version>
</dependency>
```

```java
package com.zh.thread;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

/**
 * @author Beloved
 * @date 2020/9/22 21:02
 * 多线程同步下载图片
 */
public class Test02 extends Thread{

    private String url;
    private String name;

    public Test02(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public void run() {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载文件名为："+name);
    }

    public static void main(String[] args) {
        Test02 t1 = new Test02("https://api.btstu.cn/sjbz/api.php", "1.jpg");
        Test02 t2 = new Test02("https://api.btstu.cn/sjbz/api.php", "2.jpg");
        Test02 t3 = new Test02("https://api.btstu.cn/sjbz/api.php", "3.jpg");

        t1.start();
        t2.start();
        t3.start();
    }
}

/**
 * 下载器
 */
class WebDownloader{
    // 下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常");
        }
    }
}
```

![image-20200922212218710](image-20200922212218710.png)

### 2.1.3、总结

**多线程并不是按顺序执行，而是由CPU调度**

## 2.2、Runnable

**推荐使用Runnable对象，因为Java单继承有局限性**

- 实现**Runnable接口**
- 实现**run()**方法，编写线程执行体
- 创建线程对象，调用**start()**方法启动线程

### 2.2.1、测试

```java
package com.zh.runnable;

/**
 * @author Beloved
 * @date 2020/9/22 21:27
 * 1、实现Runnable接口
 * 2、重写run方法
 * 3、执行线程需要丢入Runnable接口实现类，调用start方法
 */
public class Test01 implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("run--->"+i);
        }
    }

    public static void main(String[] args) {
        Test01 t1 = new Test01();

        new Thread(t1).start();

        for (int i = 0; i < 20; i++) {
            System.out.println("main--->"+i);
        }
    }
}
```

![image-20200922213237884](image-20200922213237884.png)

### 2.2.2、多线程下载图片

```java
package com.zh.runnable;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

/**
 * @author Beloved
 * @date 2020/9/22 21:33
 */
public class Test02 implements Runnable{

    private String url;
    private String name;

    public Test02(String url, String name) {
        this.url = url;
        this.name = name;
    }

    @Override
    public void run() {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载文件名为："+name);
    }

    public static void main(String[] args) {
        Test02 t1 = new Test02("https://api.btstu.cn/sjbz/api.php", "1.jpg");
        Test02 t2 = new Test02("https://api.btstu.cn/sjbz/api.php", "2.jpg");
        Test02 t3 = new Test02("https://api.btstu.cn/sjbz/api.php", "3.jpg");

        new Thread(t1).start();
        new Thread(t2).start();
        new Thread(t3).start();
    }
}

/**
 * 下载器
 */
class WebDownloader{
    // 下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常");
        }
    }
}
```

![image-20200922213629612](image-20200922213629612.png)

## 2.3、Callable

- 实现Callable接口，需要返回值类型
- 重写call方法，需要抛出异常
- 创建目标对象
- 创建执行服务：`ExecutorService ser = Executors.newFixedThreadPool(1);`
- 提交执行：`Future<Boolean> result = ser.submit(t1);`
- 获取结果：`boolean r = result.get();`
- 关闭服务：`ser.shutdownNow();`

### 2.3.1、多线程下载图片

```java
package com.zh.callable;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

/**
 * @author Beloved
 * @date 2020/9/22 21:48
 */
public class Test01 implements Callable<Boolean> {

    private String url;
    private String name;

    public Test01(String url, String name) {
        this.url = url;
        this.name = name;
    }

    // 自定义返回值
    @Override
    public Boolean call() throws Exception {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载文件名为："+name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Test01 t1 = new Test01("https://api.btstu.cn/sjbz/api.php", "1.jpg");
        Test01 t2 = new Test01("https://api.btstu.cn/sjbz/api.php", "2.jpg");
        Test01 t3 = new Test01("https://api.btstu.cn/sjbz/api.php", "3.jpg");

        // 创建执行服务     nThreads：多少个线程
        ExecutorService ser = Executors.newFixedThreadPool(3);

        // 提交执行
        Future<Boolean> rs1 = ser.submit(t1);
        Future<Boolean> rs2 = ser.submit(t2);
        Future<Boolean> rs3 = ser.submit(t3);

        // 获取结果
        Boolean r1 = rs1.get();
        Boolean r2 = rs2.get();
        Boolean r3 = rs3.get();

        System.out.println(r1);
        System.out.println(r2);
        System.out.println(r3);

        // 关闭服务
        ser.shutdownNow();
    }
}

/**
 * 下载器
 */
class WebDownloader{
    // 下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常");
        }
    }
}
```

![image-20200922220012406](image-20200922220012406.png)

## 2.4、总结

**继承Thread类：**

- 子类继承Thread类具备多线程能力
- 启动线程：子类对象`.start()`
- 不建议使用：避免OOP单继承局限性

**实现Runnable接口：**

- 实现接口Runnable具有多线程能力
- 启动线程：传入目标对象+Thread对象.start()
- 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

**实现Callable接口：**

- 实现接口Callable具有多线程能力
- 启动线程：见2.3
- 不推荐使用：掌握即可

# 3、并发问题

**当多个线程同时操作同一个对象时，有可能同一时间操作同一数据，导致线程不安全，数据紊乱**

## 3.1、买火车票

```java
package com.zh.concurrent;

/**
 * @author Beloved
 * @date 2020/9/22 22:12
 */
public class Test01 implements Runnable {

    // 票数
    private int ticketNums = 10;

    @Override
    public void run() {
        while (true) {
            if (ticketNums <= 0) {
                break;
            }
            // 模拟延迟
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Thread.currentThread().getName()：获取当前线程名
            System.out.println(Thread.currentThread().getName()+"--->拿到了第"+ticketNums--+"票");
        }
    }


    public static void main(String[] args) {
        Test01 t = new Test01();

        new Thread(t,"张三").start();
        new Thread(t,"李四").start();
        new Thread(t,"王五").start();
    }
}
```

![image-20200922221905763](image-20200922221905763.png)

# 4、Lamda

- 避免匿名内部类定义过多
- 可以让代码看起来简洁
- 去掉没有意义的代码，只留核心的逻辑

**其实质属于函数式编程的概念**

函数式接口的定义：

- 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口

  ```java
  public interface Runnable{
      public abstract void run();
  }
  ```

- 对于函数式接口，可以通过Lamda表达式创建该接口

  ```java
  new Thread( ()-> System.out.println("你好")).start();
  ```

## 4.1、推导Lamda

```java
package com.zh.lamda;

/**
 * @author Beloved
 * @date 2020/9/23 0:15
 */
public class TestLamda01 {

    // 3.静态内部类
    static class Like2 implements ILike{

        @Override
        public void lamda() {
            System.out.println("i like lamda--->2");
        }
    }

    public static void main(String[] args) {

        ILike like = new Like();
        like.lamda();

        like = new Like2();
        like.lamda();

        // 4.局部内部类
        class Like3 implements ILike{

            @Override
            public void lamda() {
                System.out.println("i like lamda--->3");
            }
        }
        like = new Like3();
        like.lamda();

        // 5.匿名内部类。 没有类名,必须借助接口或者父类
        like = new ILike() {
            @Override
            public void lamda() {
                System.out.println("i like lamda--->4");
            }
        };
        like.lamda();

        // 6.Lamda简化
        like = ()-> {
            System.out.println("i like lamda--->5");
        };
        like.lamda();
    }

}

// 1.定义一个函数式接口
interface ILike{
    void lamda();
}

// 2.实现类
class Like implements ILike{

    @Override
    public void lamda() {
        System.out.println("i like lamda--->1");
    }
}
```

## 4.2、Lamda简化

**去除花括号代码体前提只有一行**

```java
package com.zh.lamda;

/**
 * @author Beloved
 * @date 2020/9/23 0:27
 */
public class TestLamda02 {

    public static void main(String[] args) {

        // Lamda简化
        ILove love = (String name)->{
            System.out.println("I Love " + name);
        };

        // 简化：去除参数类型
        love = (name)->{
            System.out.println("I Love " + name);
        };

        // 简化：去除括号
        love = name->{
            System.out.println("I Love " + name);
        };

        // 简化：去除花括号
        love = name-> System.out.println("I Love " + name);

        love.love("Java");

    }
}

interface ILove{
    void love(String name);
}
```

# 5、线程状态

## 5.1、五大状态

![image-20200923195321562](image-20200923195321562.png)

![image-20200923200623544](image-20200923200623544.png)

## 5.2、线程方法

| 方法                           | 说明                                       |
| ------------------------------ | ------------------------------------------ |
| setPriority(int newPriority)   | 更改线程的优先级                           |
| static void sleep(long millis) | 在指定的毫秒数内让当前正在执行的线程休眠   |
| void join()                    | 等待该线程终止                             |
| static void yield()            | 暂停当前正在执行的线程对象，并执行其他线程 |
| void interrupt()               | 中断线程，不推荐这个方式                   |
| boolean isAlive()              | 测试线程是否处于活动状态                   |

## 5.3、停止线程

- 不推荐使用JDK提供的stop()、destroy()方法【已废弃】
- 推荐线程自己停止
- 建议使用一个标志位进行终止变量，当flag=false，则终止线程运行

```java
package com.zh.state;

/**
 * @author Beloved
 * @date 2020/9/23 20:17
 * 测试线程停止
 *  1、建议线程正常停止--->利用次数，不建议死循环
 *  2、建议使用标识位---->设置一个标志位
 *  3、不要使用stop或destroy等过时方法或JDK不建议使用的
 */
public class TestStop implements Runnable{

    // 设置标识位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while (flag){
            System.out.println("run...Thread--->"+i++);
        }
    }

    // 公开方法停止线程
    public void stop(){
        this.flag = false;
    }

    public static void main(String[] args) {
        TestStop testStop = new TestStop();

        new Thread(testStop).start();

        for (int i = 0; i < 100; i++) {
            System.out.println("main--->"+i);
            if (i == 10){
                testStop.stop();
                System.out.println("线程停止了..........");
            }
        }
    }
}
```

![image-20200923202747295](image-20200923202747295.png)

## 5.4、线程休眠

- sleep（时间）指定当前线程阻塞的毫秒数
- sleep存在异常InterruptedException
- sleep时间达到后线程进入就绪状态
- sleep可以模拟网络延时，倒计时等
- **每一个对象都有一个锁，sleep不会释放锁**

可以模拟网络延迟（见前面抢票）、模拟倒计时

```java
package com.zh.state;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.SimpleFormatter;

/**
 * @author Beloved
 * @date 2020/9/23 20:39
 */
public class TestSleep {

    public static void main(String[] args) {
        // 打印当前系统时间
        Date date = new Date(System.currentTimeMillis()); // 获取系统当前时间

        while (true){
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat("HH:mm:ss").format(date));
                date = new Date(System.currentTimeMillis()); // 更新当前时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    // 模拟倒计时
    public static void tenDown() throws InterruptedException {
        int num = 10;
        while (true){
            Thread.sleep(1000);
            System.out.println(num--);
            if (num<=0){
                break;
            }
        }
    }

}
```

## 5.5、线程礼让

- 礼让线程，让当前正在执行的线程暂停，但不阻塞
- 将线程从运行状态转为就绪状态
- **让CPU重新调度，礼让不一定成功！看CPU心情**

**多次运行，查看不同的结果**

```java
package com.zh.state;

/**
 * @author Beloved
 * @date 2020/9/23 20:50
 * 测试礼让线程
 *  礼让不一定成功
 */
public class TestYield {

    public static void main(String[] args) {

        MyYield myYield = new MyYield();

        new Thread(myYield,"A").start();
        new Thread(myYield,"B").start();
    }
}

class MyYield implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"--->线程开始执行");
        Thread.yield(); // 礼让
        System.out.println(Thread.currentThread().getName()+"--->线程停止执行");
    }
}
```

## 5.6、强制执行

- Join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞
- 可以想象成插队

主线程等待插队线程执行完毕才继续执行

```java
package com.zh.state;

/**
 * @author Beloved
 * @date 2020/9/23 20:57
 */
public class TestJoin implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("VIP线程--->"+i);
        }
    }

    public static void main(String[] args) {
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        // 主线程
        for (int i = 0; i < 10; i++) {
            if (i==5){
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("main--->"+i);
        }
    }
}
```

![image-20200923210030851](image-20200923210030851.png)

## 5.7、状态观测

**线程状态（Thread.state）:**

- NEW：尚未启动的线程处于次状态
- RUNNABLE：在Java虚拟机中执行的线程处于次状态
- BLOCKED：被阻塞等待监视器锁定的线程处于次状态
- WAITING：正在等待另一个线程执行特定动作的线程处于此状态
- TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
- TERMINATED：已退出的线程处于此状态

一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态

```java
package com.zh.state;

/**
 * @author Beloved
 * @date 2020/9/23 21:10
 * 测试线程状态
 */
public class TestState {

    public static void main(String[] args) {

        Thread thread = new Thread(()->{
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("----------------------------");
        });


        // 观察状态
        Thread.State state = thread.getState();
        System.out.println(state);   // NEW  还未启动

        // 观察启动后
        thread.start();// 启动线程
        state = thread.getState();
        System.out.println(state); // RUN

        while (state != Thread.State.TERMINATED){ // 只要线程不终止，就一直输出状态
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            state = thread.getState(); // 更新线程状态
            System.out.println(state); // 输出状态
        }
        
        // thread.start();  线程已经死了，再次启动就会报错
    }

}
```

![image-20200923211948555](image-20200923211948555.png)

## 5.8、优先级

- Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程执行
- 线程优先级用数字表示，范围从1~10
  - Thread.MIN_PRIORITY = 1
  - Thread.NORM_PRIORITY = 5
  - Thread.MAX_PRIORITY = 10
- 使用以下方式改变或获取优先级
  - getPriority() 
  - .setPriority(int xxx)
- **优先级的设定建议在start()调度前**
- 优先级低只是意味着获得的调度概率低，并不是优先级低就不会被调用了，都是看CPU的调度

**多次运行，查看启动顺序**

```java
package com.zh.state;

/**
 * @author Beloved
 * @date 2020/9/23 21:31
 * 测试优先级
 * 优先级范围 1 ~ 10
 */
public class TestPriority {

    public static void main(String[] args) {
        // 主线程默认优先级
        System.out.println(Thread.currentThread().getName()+"--->"+Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();

        Thread t1 = new Thread(myPriority, "t1");
        Thread t2 = new Thread(myPriority, "t2");
        Thread t3 = new Thread(myPriority, "t3");
        Thread t4 = new Thread(myPriority, "t4");
        Thread t5 = new Thread(myPriority, "t5");
        Thread t6 = new Thread(myPriority, "t6");

        // 先设置优先级在启动
        t1.start(); // 默认

        t2.setPriority(Thread.MIN_PRIORITY); // MIN_PRIORITY = 1
        t2.start();

        t3.setPriority(Thread.NORM_PRIORITY); // NORM_PRIORITY = 5
        t3.start();

        t4.setPriority(Thread.MAX_PRIORITY); // MAX_PRIORITY = 10
        t4.start();

        //t5.setPriority(-1); // 超出范围报错
        t5.setPriority(3);
        t5.start();

        //t6.setPriority(11); // 超出范围报错
        t6.setPriority(8);
        t6.start();
    }

}

class MyPriority implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"--->"+Thread.currentThread().getPriority());
    }
}
```

## 5.9、守护线程

- 线程分为**用户线程**和**守护线程**
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不用等待守护线程执行完毕
- 如：后台记录操作日志，监控内存，垃圾回收等待...

**用户线程结束，整个程序就会停止**

```java
package com.zh.state;

/**
 * @author Beloved
 * @date 2020/9/23 22:29
 * 测试守护线程
 *  虚拟机不会管守护线程
 *  用户线程结束，程序就会结束
 */
public class TestDaemon {

    public static void main(String[] args) {
        God god = new God();
        You you = new You();

        Thread thread = new Thread(god);
        thread.setDaemon(true); // 默认是false表示用户线程，正常的线程都是用户线程

        thread.start(); // 守护线程启动

        new Thread(you).start(); // 用户线程启动

    }
}

// 上帝：守护线程
class God implements Runnable{

    @Override
    public void run() {
        while (true){
            System.out.println("上帝保佑你");
        }
    }
}

// 你：用户线程
class You implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 36500; i++) {
            System.out.println("每一天都开心的活着");
        }
        System.out.println("========goodbye! world!==========");
    }
}
```





